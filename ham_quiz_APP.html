<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Amateur Radio Exam Practice</title>
<style>
body {
font-family: Arial, sans-serif;
max-width: 800px;
margin: 20px auto;
padding: 10px;
line-height: 1.5;
}
h1 {
text-align: center;
}
.card {
border: 1px solid #ccc;
border-radius: 8px;
padding: 16px;
margin-top: 16px;
box-shadow: 0 2px 4px rgba(0,0,0,0.08);
}
.controls {
margin-top: 10px;
display: flex;
gap: 10px;
flex-wrap: wrap;
}
button {
padding: 8px 14px;
border-radius: 6px;
border: 1px solid #888;
background: #f2f2f2;
cursor: pointer;
font-size: 14px;
}
button:disabled {
opacity: 0.6;
cursor: not-allowed;
}
#status {
margin-top: 8px;
font-size: 0.95rem;
color: #555;
}
#bankQuestionId {
font-weight: bold;
margin-bottom: 4px;
color: #333;
}
#questionText {
font-weight: bold;
margin-bottom: 10px;
}
.option-label {
display: block;
margin-bottom: 6px;
padding: 4px 6px;
border-radius: 4px;
transition: background 0.2s;
}
.option-label.correct {
background: #d6f5d6;
}
.option-label.incorrect {
background: #ffd6d6;
}
#feedback {
margin-top: 10px;
font-weight: bold;
}
#feedback.correct {
color: #1c7c1c;
}
#feedback.incorrect {
color: #b00000;
}
#explanation {
margin-top: 6px;
font-style: italic;
color: #444;
/* Show \n as real line breaks */
white-space: pre-line;
}
#score {
margin-top: 10px;
font-size: 0.95rem;
}
#wrongInfo {
font-size: 0.9rem;
color: #555;
}
</style>
</head>
<body>
<h1>Amateur Radio Exam Practice</h1>

<div class="card">
<p><strong>Step 1:</strong> Export your Excel question bank as a <strong>CSV</strong> file, then load it here.</p>
<p>This version supports:</p>
<ul>
<li><strong>Vertical format</strong> (your bank): header <code>Column,Example</code>, then rows like <code>question,...</code>, <code>optionA,...</code>, <code>correctOption,...</code>, <code>BankQuestionID,...</code>, etc. (multi-line explanations OK)</li>
<li><strong>Horizontal format</strong>: one row per question with <code>question,optionA,optionB,optionC,optionD,correctOption,explanation,BankQuestionID</code> (BankQuestionID optional)</li>
</ul>
<input type="file" id="fileInput" accept=".csv">
<div id="status">No file loaded.</div>
<div id="modeControls" style="margin-top:8px;">
<strong>Question mode:</strong>
<label><input type="radio" name="mode" id="modeRandom" value="random" checked> Random</label>
<label style="margin-left: 10px;"><input type="radio" name="mode" id="modeNoRepeat" value="norepeat"> No repeats until all questions used</label>
<label style="margin-left: 10px;"><input type="radio" name="mode" id="modeExam" value="exam"> Exam (100-question subset)</label>
</div>
</div>

<div class="card" id="quizCard" style="display:none;">
<div id="questionHeader">
<span id="questionCounter"></span>
</div>
<div id="bankQuestionId"></div>
<div id="questionText"></div>
<form id="optionsForm">
<div id="options"></div>
</form>

<div id="feedback"></div>
<div id="explanation"></div>

<div class="controls">
<button id="checkBtn">Check Answer</button>
<button id="nextBtn" disabled>Next Question</button>
</div>

<div id="score"></div>
<div id="categoryReport"></div>
</div>

<div class="card" id="wrongCard" style="display:none;">
<h3>Wrong Questions Tracker</h3>
<p id="wrongInfo">You haven’t missed any questions yet.</p>
<button id="downloadWrongBtn" disabled>Download wrong questions CSV</button>
</div>

<script>
// Data structure:
// {
// bankID, // BankQuestionID (string, may be empty)
// question,
// options: [A,B,C,D],
// correctIndex,
// explanation,
// raw: {
// bankID,
// question,
// optionA,
// optionB,
// optionC,
// optionD,
// correctLetter,
// explanation
// }
// }
let questions = [];
let currentQuestionIndex = null;
let totalAsked = 0;
let totalCorrect = 0;

let wrongQuestions = []; // raw objects

// Category definitions (from ISED Basic exam structure)
const CATEGORY_INFO = {
  '001': 'Regulations and Policies',
  '002': 'Operating and Procedures',
  '003': 'Station Assembly, Practice and Safety',
  '004': 'Circuit Components',
  '005': 'Basic Electronics and Theory',
  '006': 'Feedlines and Antenna Systems',
  '007': 'Radio Wave Propagation',
  '008': 'Interference and Suppression'
};

// Per-exam category statistics
let categoryStats = {};

const fileInput = document.getElementById('fileInput');
const statusEl = document.getElementById('status');
const quizCard = document.getElementById('quizCard');
const bankQuestionIdEl = document.getElementById('bankQuestionId');
const questionTextEl = document.getElementById('questionText');
const optionsEl = document.getElementById('options');
const optionsForm = document.getElementById('optionsForm');
const feedbackEl = document.getElementById('feedback');
const explanationEl = document.getElementById('explanation');
const questionCounterEl = document.getElementById('questionCounter');
const scoreEl = document.getElementById('score');
const checkBtn = document.getElementById('checkBtn');
const nextBtn = document.getElementById('nextBtn');
const modeRandomRadio = document.getElementById('modeRandom');
const modeNoRepeatRadio = document.getElementById('modeNoRepeat');
const modeExamRadio = document.getElementById('modeExam');
let selectionMode = 'random';
let questionSequence = [];
let questionSequencePosition = 0;

modeRandomRadio.addEventListener('change', () => {
  if (modeRandomRadio.checked) {
    selectionMode = 'random';
  }
});

modeNoRepeatRadio.addEventListener('change', () => {
  if (modeNoRepeatRadio.checked) {
    selectionMode = 'norepeat';
    resetQuestionSequence();
  }
});

modeExamRadio.addEventListener('change', () => {
  if (modeExamRadio.checked) {
    selectionMode = 'exam';
    // Reset stats for a fresh exam session
    totalAsked = 0;
    totalCorrect = 0;
    wrongQuestions = [];
    updateScore();
    updateWrongInfo();
    resetQuestionSequence();
    if (categoryReportEl) {
      categoryReportEl.innerHTML = '';
    }
    statusEl.textContent = 'Exam mode: up to 100 random questions selected from the loaded bank.';
    nextBtn.disabled = false;
  }
});

const wrongCard = document.getElementById('wrongCard');
const wrongInfoEl = document.getElementById('wrongInfo');
const downloadWrongBtn = document.getElementById('downloadWrongBtn');
const categoryReportEl = document.getElementById('categoryReport');

fileInput.addEventListener('change', handleFileSelect);
checkBtn.addEventListener('click', handleCheckAnswer);
nextBtn.addEventListener('click', showNextQuestion);
downloadWrongBtn.addEventListener('click', downloadWrongQuestionsCsv);

// === Real CSV parser that supports:
// - commas in fields
// - quotes
// - double quotes ("") as escaped quotes
// - multi-line fields (line breaks inside quoted fields)
function parseCsvText(text) {
const rows = [];
let row = [];
let field = '';
let inQuotes = false;

for (let i = 0; i < text.length; i++) {
const ch = text[i];

if (inQuotes) {
if (ch === '"') {
// Check for escaped quote ("")
if (i + 1 < text.length && text[i + 1] === '"') {
field += '"';
i++; // skip the second quote
} else {
inQuotes = false;
}
} else {
field += ch;
}
} else {
if (ch === '"') {
inQuotes = true;
} else if (ch === ',') {
row.push(field);
field = '';
} else if (ch === '\r' || ch === '\n') {
// End of record (if we are not in quotes)
row.push(field);
field = '';
// Only push non-empty rows (or rows with at least one non-empty cell)
if (row.some(cell => cell.trim() !== '')) {
rows.push(row);
}
row = [];
// Skip \n after \r for CRLF
if (ch === '\r' && i + 1 < text.length && text[i + 1] === '\n') {
i++;
}
} else {
field += ch;
}
}
}

// Last field / last row
if (field.length > 0 || row.length > 0) {
row.push(field);
if (row.some(cell => cell.trim() !== '')) {
rows.push(row);
}
}

return rows;
}

function handleFileSelect(event) {
const file = event.target.files[0];
if (!file) return;

const reader = new FileReader();
reader.onload = function(e) {
const text = e.target.result;
try {
questions = parseCsvToQuestions(text);
if (questions.length === 0) {
statusEl.textContent = 'No valid questions found in the file. Check the format.';
quizCard.style.display = 'none';
wrongCard.style.display = 'none';
} else {
statusEl.textContent = `Loaded ${questions.length} questions. Click "Next Question" to start.`;
quizCard.style.display = 'block';
wrongCard.style.display = 'block';

totalAsked = 0;
totalCorrect = 0;
wrongQuestions = [];
updateScore();
updateWrongInfo();

resetQuestionSequence();
resetFeedback();
clearQuestion();
nextBtn.disabled = false;
checkBtn.disabled = true;
}
} catch (err) {
console.error(err);
statusEl.textContent = 'Error reading the file. Check the format and try again.';
quizCard.style.display = 'none';
wrongCard.style.display = 'none';
}
};
reader.readAsText(file);
}

function parseCsvToQuestions(csvText) {
const rows = parseCsvText(csvText);
const result = [];
if (!rows.length) return result;

const firstRow = rows[0];
const firstCell = (firstRow[0] || '').trim().toLowerCase();

const isVerticalFormat = firstRow.length >= 2 && firstCell === 'column';

if (isVerticalFormat) {
return parseVerticalQuestions(rows);
}

// Horizontal format: one row per question
let startIndex = 0;
if (firstCell.includes('question')) {
startIndex = 1; // skip header row
}

for (let i = startIndex; i < rows.length; i++) {
const cells = rows[i];
if (!cells || cells.length < 6) continue;

const question = (cells[0] || '').trim();
const optionA = (cells[1] || '').trim();
const optionB = (cells[2] || '').trim();
const optionC = (cells[3] || '').trim();
const optionD = (cells[4] || '').trim();
const correct = (cells[5] || '').trim();
const explanation = cells[6] ? cells[6].toString() : '';

// Optional BankQuestionID in horizontal format (column 8)
const bankID = cells[7] ? cells[7].toString().trim() : '';

if (!question || !optionA || !optionB || !optionC || !optionD || !correct) {
continue;
}

const correctIndex = letterToIndex(correct);
if (correctIndex === null) continue;
const correctLetter = indexToLetter(correctIndex);

const category = getCategoryFromBankID(bankID);

result.push({
bankID,
category,
question,
options: [optionA, optionB, optionC, optionD],
correctIndex,
explanation,
raw: {
bankID,
category,
question,
optionA,
optionB,
optionC,
optionD,
correctLetter,
explanation
}
});
}

return result;
}

// Extract category code (001–008) from BankQuestionID like "B-001-001-002"
function getCategoryFromBankID(bankId) {
if (!bankId) return null;
const m = bankId.match(/^B-(\d{3})-/);
return m ? m[1] : null;
}

// Vertical format: header row "Column,Example", then key/value rows
function parseVerticalQuestions(rows) {
const result = [];
// rows[0] is header
let current = null;

function pushCurrent() {
if (!current) return;
if (!current.question || !current.optionA || !current.optionB ||
!current.optionC || !current.optionD || !current.correctLetter) {
return;
}
const correctIndex = letterToIndex(current.correctLetter);
if (correctIndex === null) return;

const bankID = current.bankID ? current.bankID.trim() : '';

const category = getCategoryFromBankID(bankID);

const q = {
bankID,
category,
question: current.question,
options: [current.optionA, current.optionB, current.optionC, current.optionD],
correctIndex,
explanation: current.explanation || '',
raw: {
bankID,
category,
question: current.question,
optionA: current.optionA,
optionB: current.optionB,
optionC: current.optionC,
optionD: current.optionD,
correctLetter: indexToLetter(correctIndex),
explanation: current.explanation || ''
}
};
result.push(q);
}

for (let i = 1; i < rows.length; i++) {
const row = rows[i];
if (!row || row.length < 2) continue;

const key = (row[0] || '').trim();
const value = (row[1] || '').toString(); // may contain \n inside

if (!key) continue;

const keyLower = key.toLowerCase();
if (keyLower === 'question') {
// New question; push previous if valid
if (current) pushCurrent();
current = {
bankID: '',
question: value.trim(),
optionA: '',
optionB: '',
optionC: '',
optionD: '',
correctLetter: '',
explanation: ''
};
} else if (current) {
if (keyLower === 'optiona') current.optionA = value.trim();
else if (keyLower === 'optionb') current.optionB = value.trim();
else if (keyLower === 'optionc') current.optionC = value.trim();
else if (keyLower === 'optiond') current.optionD = value.trim();
else if (keyLower === 'correctoption') current.correctLetter = value.trim();
else if (keyLower === 'explanation') current.explanation = value;
else if (keyLower === 'bankquestionid') current.bankID = value.trim();
}
}

if (current) pushCurrent();
return result;
}

function letterToIndex(letter) {
const l = letter.toString().trim().toUpperCase();
if (l === 'A') return 0;
if (l === 'B') return 1;
if (l === 'C') return 2;
if (l === 'D') return 3;
const num = parseInt(l, 10);
if (!isNaN(num) && num >= 0 && num <= 3) return num;
return null;
}

function indexToLetter(index) {
return String.fromCharCode(65 + index);
}

function resetQuestionSequence() {
  // Prepare a shuffled sequence of question indices for no-repeat or exam mode
  questionSequence = [];
  questionSequencePosition = 0;
  if (selectionMode !== 'norepeat' && selectionMode !== 'exam') {
    return;
  }
  if (!questions || questions.length === 0) {
    return;
  }
  const indices = [];
  for (let i = 0; i < questions.length; i++) {
    indices.push(i);
  }
  // Fisher-Yates shuffle
  for (let i = indices.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = indices[i];
    indices[i] = indices[j];
    indices[j] = tmp;
  }
  if (selectionMode === 'exam') {
    const limit = Math.min(100, indices.length);
    questionSequence = indices.slice(0, limit);
    // Initialize per-category totals for the current exam question set
    resetCategoryStatsForExam();
  } else {
    questionSequence = indices;
  }
}

function resetCategoryStatsForExam() {
  categoryStats = {};
  for (const code in CATEGORY_INFO) {
    categoryStats[code] = { correct: 0, total: 0 };
  }
  if (selectionMode === 'exam' && questionSequence && questionSequence.length > 0) {
    questionSequence.forEach(idx => {
      const q = questions[idx];
      if (q && q.category && categoryStats[q.category]) {
        categoryStats[q.category].total += 1;
      }
    });
  }
}


function showNextQuestion() {
if (questions.length === 0) return;

resetFeedback();
let index;
if (selectionMode === 'norepeat' || selectionMode === 'exam') {
  if (!questionSequence || questionSequence.length === 0) {
    resetQuestionSequence();
  }
  if (questionSequence.length === 0) {
    return;
  }
  if (questionSequencePosition >= questionSequence.length) {
    if (selectionMode === 'exam') {
      statusEl.textContent = 'Exam complete: you have answered all questions in this exam set.';
      nextBtn.disabled = true;
      return;
    } else {
      // All questions have been used once; reshuffle for a new cycle
      resetQuestionSequence();
      statusEl.textContent = 'You have seen all questions once. Starting a new shuffled cycle.';
    }
  }
  index = questionSequence[questionSequencePosition++];
} else {
  index = Math.floor(Math.random() * questions.length);
}
currentQuestionIndex = index;
const q = questions[index];


// Show BankQuestionID above the question (if present)
if (q.bankID && q.bankID.trim() !== '') {
bankQuestionIdEl.textContent = `BankQuestionID: ${q.bankID}`;
} else {
bankQuestionIdEl.textContent = '';
}

questionTextEl.innerHTML = q.question;
questionCounterEl.textContent = `Question ${totalAsked + 1}`;
optionsEl.innerHTML = '';

q.options.forEach((opt, index) => {
const id = `opt_${index}`;

const label = document.createElement('label');
label.className = 'option-label';
label.setAttribute('data-index', index);

const input = document.createElement('input');
input.type = 'radio';
input.name = 'option';
input.value = index;
input.id = id;

const letter = String.fromCharCode(65 + index);
const span = document.createElement('span');
span.innerHTML = ' ' + letter + ') ' + opt;

label.appendChild(input);
label.appendChild(span);
optionsEl.appendChild(label);
});

checkBtn.disabled = false;
nextBtn.disabled = true;
}

function handleCheckAnswer(event) {
event.preventDefault();
if (currentQuestionIndex === null) return;

const selectedInput = optionsForm.querySelector('input[name="option"]:checked');
if (!selectedInput) {
alert('Please select an answer.');
return;
}

const selectedIndex = parseInt(selectedInput.value, 10);
const q = questions[currentQuestionIndex];

totalAsked++;
const isCorrect = (selectedIndex === q.correctIndex);
if (isCorrect) {
totalCorrect++;
} else {
addWrongQuestion(q.raw);
}

// Update per-category stats in exam mode
if (selectionMode === 'exam' && q && q.category && categoryStats && categoryStats[q.category]) {
  if (isCorrect) {
    categoryStats[q.category].correct += 1;
  }
}

highlightOptions(selectedIndex, q.correctIndex);
showFeedback(isCorrect, q);

updateScore();
updateWrongInfo();

checkBtn.disabled = true;
nextBtn.disabled = false;
}

function addWrongQuestion(rawQuestion) {
const exists = wrongQuestions.some(w =>
w.question === rawQuestion.question &&
w.correctLetter === rawQuestion.correctLetter &&
(w.bankID || '') === (rawQuestion.bankID || '')
);
if (!exists) {
wrongQuestions.push({ ...rawQuestion });
}
}

function highlightOptions(selectedIndex, correctIndex) {
const labels = optionsEl.querySelectorAll('.option-label');
labels.forEach(label => {
const idx = parseInt(label.getAttribute('data-index'), 10);
label.classList.remove('correct', 'incorrect');

if (idx === correctIndex) {
label.classList.add('correct');
}
if (idx === selectedIndex && idx !== correctIndex) {
label.classList.add('incorrect');
}
});
}

function showFeedback(isCorrect, questionObj) {
feedbackEl.textContent = isCorrect ? 'Correct!' : 'Incorrect.';
feedbackEl.className = '';
feedbackEl.classList.add(isCorrect ? 'correct' : 'incorrect');

if (questionObj.explanation) {
// Render explanation as HTML so tables and formatting work
explanationEl.innerHTML = '<strong>Explanation:</strong><br>' + questionObj.explanation;
} else {
explanationEl.innerHTML = '';
}
}

function updateScore() {
if (totalAsked === 0) {
scoreEl.textContent = 'Score: –';
if (categoryReportEl) {
  categoryReportEl.innerHTML = '';
}
} else {
const percent = ((totalCorrect / totalAsked) * 100).toFixed(1);
let message = `Score: ${totalCorrect} / ${totalAsked} (${percent}%)`;

// Only show pass / honours result and category breakdown at the END of an exam
if (
  selectionMode === 'exam' &&
  questionSequence &&
  questionSequence.length > 0 &&
  totalAsked === questionSequence.length
) {
  const p = parseFloat(percent);
  if (p >= 80) {
    message += ' — Pass with honours';
  } else if (p >= 70) {
    message += ' — Pass';
  } else {
    message += ' — Below pass';
  }

  // Build category breakdown similar to ISED report
  if (categoryReportEl && categoryStats) {
    let html = '<h3>Category Breakdown</h3>';
    html += '<table border="1" cellpadding="4" cellspacing="0">';
    html += '<tr><th>Category</th><th>Correct Answers</th><th>Questions</th><th>Percent</th></tr>';

    for (const code in CATEGORY_INFO) {
      const st = categoryStats[code] || { correct: 0, total: 0 };
      const pct = st.total > 0 ? Math.round((st.correct / st.total) * 100) : 0;
      html += `<tr>
<td>${code} - ${CATEGORY_INFO[code]}</td>
<td>${st.correct}</td>
<td>${st.total}</td>
<td>${pct}%</td>
</tr>`;
    }

    html += '</table>';
    categoryReportEl.innerHTML = html;
  }
} else {
  // Not exam finished: clear category report in exam mode
  if (selectionMode === 'exam' && categoryReportEl) {
    categoryReportEl.innerHTML = '';
  }
}

scoreEl.textContent = message;
}
}


function resetFeedback() {
feedbackEl.textContent = '';
feedbackEl.className = '';
explanationEl.innerHTML = '';
}

function clearQuestion() {
bankQuestionIdEl.textContent = '';
questionTextEl.innerHTML = '';
optionsEl.innerHTML = '';
questionCounterEl.textContent = '';
}

function updateWrongInfo() {
if (wrongQuestions.length === 0) {
wrongInfoEl.textContent = 'You haven’t missed any questions yet.';
downloadWrongBtn.disabled = true;
} else {
wrongInfoEl.textContent = `You have missed ${wrongQuestions.length} unique question(s). You can download them as a CSV and re-upload later to practice only those.`;
downloadWrongBtn.disabled = false;
}
}

function downloadWrongQuestionsCsv() {
if (wrongQuestions.length === 0) return;

// Include BankQuestionID as first column
let csv = 'BankQuestionID,question,optionA,optionB,optionC,optionD,correctOption,explanation\n';

wrongQuestions.forEach(q => {
const row = [
q.bankID || '',
q.question,
q.optionA,
q.optionB,
q.optionC,
q.optionD,
q.correctLetter,
q.explanation || ''
].map(escapeCsvField).join(',');
csv += row + '\n';
});

const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
const url = URL.createObjectURL(blob);

const a = document.createElement('a');
a.href = url;
const now = new Date();
const timestamp = now.toISOString().slice(0, 19).replace(/[:T]/g, '-');
a.download = `wrong_questions_${timestamp}.csv`;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);
}

function escapeCsvField(value) {
if (value == null) return '';
let str = value.toString();
if (/[",\n\r]/.test(str)) {
str = '"' + str.replace(/"/g, '""') + '"';
}
return str;
}
</script>
</body>
</html>